Some routes of the application should not be accessible to all users, depending on their
permissions. Of course, you should hide or disable links pointing to these routes if the user may not
access them. You should also make sure the backend doesn’t allow accessing or modifying
resources that the user isn’t authorized to access or modify. But that still won’t prevent users from
accessing routes that they’re not allowed to access, who can simply enter their URL in the address
bar.

That’s where navigation guards come into play. There are 3 kinds of guards:
• global guards: they apply to all the routes of the application;
• route guards: they apply to the route where they are defined;
• in-component guards: they apply to the component where they are defined.
Let’s start with the global ones!

20.9.1 Global Guards

Global guards are registered directly on the routerPlugin instance. The guards are automatically
called by the router when the route changes (i.e. not when the params or query params change,
only when the router is about to activate a different route!).
beforeEach
The most common one is beforeEach:

```js
routerPlugin.beforeEach((to: RouteLocationNormalized, from: RouteLocationNormalized)
=> {
return to.name === 'login' || isLoggedIn;
// or `return to.name === 'login' || isLoggedIn || '/login'` to redirect
});
```

As you can see, the guard is a function that takes two parameters:
• from is the Route where we come from;
• to is the Route where we go to.
The guard showed in the example is pretty simple: if the user tries to navigate to the login page, or
is logged in, we return true (or nothing) to confirm the navigation. If not, we return false to abort
it. You can return '/login' or { name: 'login' } if you want to redirect the user to specific page. You can also return a Promise if the decision is asynchronous.

