Letâ€™s imagine a component Order where a user can order a product with a certain quantity. We
want to display the product information and the total price. We also want to let the user increase or decrease the quantity. And finally, we want to track when the user enters and exits the component, for analytics purpose.

One of the interesting aspects of the Composition API is that all the code related to a given concern can be written in a single place, separated from the code related to other concerns. And we can even extract some shared component logic outside of components.

order.vue Messy code

```js
setup(props) {
const product = ref<ProductModel | null>(null);
const quantity = ref(0);
const price = computed(() => quantity.value * (product.value?.unitPrice ?? 0));
onMounted(async () => {
// log a trace that the user entered this page
await trace('enter');
});
// fetch the product data on initialization and refresh them if the props change
watchEffect(async () => {
product.value = await getProduct(props.productId);
});
function increaseQuantity() {
quantity.value += 1;
}
function decreaseQuantity() {
if (quantity.value > 0) {
quantity.value -= 1;
}
}
async function order() {
// place the order
}
onUnmounted(async () => {
// log a trace that the user left this page
await trace('exit');
});
return { product, quantity, price, increaseQuantity, decreaseQuantity, order };
}
```

This is fairly understandable, but the different concerns of the component are mixed with each
other.

It would have been even worse in Vue 2.x. As you may know, the Composition API has been
introduced in Vue 3.0. Previously, you had to use (and you can still use) the Options API with
several fields to declare:

