
We very often need client-side validation in forms. This is not a replacement for server-side
validation, but it’s nice to tell our users that some values are incorrect in the current form. It also
gives instant feedback, unlike server-side validation.

VeeValidate is here to help us. It works with the v-model directive we just discovered and adds some
nifty features to our forms.

VeeValidate comes with a lot of validation rules, but none of them are included by default. They are
provided in a separate package called @vee-validate/rules. To make your application as small as
possible, you have to declare what validation rules you want to use. You can import all of them at
once, but this is not a good idea, as you’ll probably just use a few.
Let’s list the most common validation rules available:


Let’s list the most common validation rules available:
• required to make a field required
• min:N and max:N to make sure the value has at least/at most N characters
• min_value:N, max_value:N, between to make sure the value is at least/at most N for a number, or
between two values
• email to check if the value is a valid email
• url to check if the value is a valid URL
• alpha, alpha_num, alpha_dash, alpha_space to check that the value is alphabetic only/with
numbers/with dashes/with spaces
• numeric to check that the value is a number
• regex to define your own regular expression
You have some specific rules for inputs of type="file":
• mimes allows defining what MIME types you want to accept for this file
• ext allows defining what extensions you want to accept for this file
• size allows defining the maximum file size
• image only allows image formats
• dimensions allows defining the exact image dimensions
Some rules are meant to cross-validate two fields:
• required_if makes a field required if another one is filled with one of the given values
• confirmed checks if a field has the same value as another one (classical password/confirm
password check).

When you want to use a rule in your application, you have to load it:

```js
import { defineRule } from 'vee-validate';
import { confirmed, min, required } from '@vee-validate/rules';
defineRule('min', min);
defineRule('required', required);
defineRule('confirmed', confirmed);
```

As you can see, we could rename the rules, but I usually use the default rule names. Once we
defined the rules we want to use, we can use them in our components to validate inputs.
You can also configure VeeValidate, for example to indicate when the validation happens. By
default, it validates on the events blur and change. But I like to validate on the input event as well


```js
import { configure } from 'vee-validate';
configure({
validateOnInput: true,
});
```

VeeValidate offers two ways to add validations to your forms:
• one based on the Composition API
• one based on components to use in your templates (a pattern called Higher Order Components,
or HOC)

22.2.1. VeeValidate with Composition API

```js
import { useField } from 'vee-validate';
const { value: name, errorMessage: nameErrorMessage, meta: nameMeta } = useField('
name', { required: true });
```

The object returned by useField() has several interesting properties, like the value of the field, that
we can use in a v-model. VeeValidate also handles the validation of the field, and offers an
errorMessage property, which contains the potential error message for our input.

```js
<template>
<label for="name">Name</label>
<input id="name" v-model="name" name="name" />
<div v-if="nameMeta.dirty && !nameMeta.valid" class="error">{{ nameErrorMessage
}}</div>
</template>
<script setup lang="ts">
import { useField } from 'vee-validate';
const { value: name, errorMessage: nameErrorMessage, meta: nameMeta } = useField('
name', { required: true });
</script>
```

useField in fact offers more properties than that on meta:
• valid is a boolean indicating if the field is valid or invalid
• dirty is a boolean indicating if the field is pristine (no value was entered) or dirty (the user
entered a value different than the initial one)
• touched is a boolean indicating if the field has been blurred or not
VeeValidate also helps to validate the whole form state, and provides another composition API
function: useForm().

```js
import { useField, useForm } from 'vee-validate';
const { meta: formMeta, handleSubmit, errors } = useForm();
// add a `name` field to the form, initialized with 'JB'
const { value: name } = useField('name', { required: true }, { initialValue: 'JB' });
// add a `password` field to the form
const { value: password } = useField('password', { required: true });
// the register function has access to the form values directly
const register = handleSubmit(values => {
// this will only be called if the form is valid
console.log(values);
});
```

You can register as many fields as you want. useForm returns an object with a function handleSubmit
that we can use to handle the submission, an object errors, containing the validation errors, and
the same properties as useField in a property meta. With a logic fairly easy to follow: valid is true if
every field is valid, and false if at least one field is invalid; dirty is false if every field is pristine,
and true if at least one field is dirty, etc.
For example, you can disable the submit button of the form if it is invalid:

```js
<template>
<form @submit="register()">
<label for="name">Name</label>
<input id="name" v-model="name" />
<div class="error">{{ errors.name }}</div>
<label for="password">Password</label>
<input id="password" v-model="password" type="password" />
<div class="error">{{ errors.password }}</div>
<!-- button is disabled while the form is invalid -->
<button :disabled="!formMeta.valid">Register</button>
</form>
</template>
<script setup lang="ts">
import { useField, useForm } from 'vee-validate';
177
const { meta: formMeta, handleSubmit, errors } = useForm();
// add a `name` field to the form, initialized with 'JB'
const { value: name } = useField('name', { required: true }, { initialValue: 'JB' });
// add a `password` field to the form
const { value: password } = useField('password', { required: true });
// the register function has access to the form values directly
const register = handleSubmit(values => {
// this will only be called if the form is valid
console.log(values);
});
</script>
```




