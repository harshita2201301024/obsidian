You can apply the v-model directive to an input, a textarea or a select. You give it a property to
update, and it automatically keeps it in sync between the code and the form field.

This is called two-way binding:
• if the property value changes in the code, the value displayed in the template is updated;
• if the user enters a new value, the property value is updated in the code.
\
```js
<!-- `user.name` is updated every time the user enters a value -->
<!-- every time the code changes `user.name`, v-model changes the input value -->
<!-- the binding is thus two-way -->
<input v-model="user.name" />
```

```js
const user = reactive({
name: '',
age: 18,
profile: null,
isAdmin: false
});
```

v-model is in fact just a syntactic sugar, equivalent (for an input) to:
\
```js
<input :value="user.name" @input="user.name = ($event.target as
HTMLInputElement).value" />
<!-- the `as HTMLInputElement` part is just to help template type checking tools -->
<!-- this is the same as `$event.target.value` -->
```


You can see the two-way binding more clearly:

• if user.name changes, the value is updated
• if the user enters a value, the input event fires, and updates user.name.

It also works with checkboxes:
\
```js
 <input v-model="user.isAdmin" type="checkbox" />
<!-- displays "Is admin: true" or "Is admin: false" -->
<p>Is admin: {{ user.isAdmin }}</p>
```

But sometimes you don’t want true or false. In that case v-model offers true-value and false-value:

```js
<input v-model="user.isAdmin" type="checkbox" true-value="yes" false-value="no" />
<!-- displays "Is admin: yes" or "Is admin: no" -->
<p>Is admin: {{ user.isAdmin }}</p>
```

It also works with radio buttons, with static or dynamic options:

```js
const profiles = ['developer', 'accountant', 'manager'];
const user = reactive({
name: '',
age: 18,
profile: null,
isAdmin: false
});
```



