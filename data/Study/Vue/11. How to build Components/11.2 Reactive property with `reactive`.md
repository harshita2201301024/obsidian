ref is really handy when working with primitives, as there is no other way to tell Vue that a primitive is reactive. But when working with objects, it can be a bit cumbersome to always write .value.property to update one property of the underlying object:

```js
export default defineComponent({
name: 'Pony',
setup() {
const pony = ref({
name: 'Rainbow Dash',
color: 'GREEN'
});
// update the name after 3 seconds
setTimeout(() => {
pony.value.name = 'Pinkie Pie';
}, 3000);
return { pony };
}
});
```

Thatâ€™s where reactive() can help! It is very similar to ref in the sense that it declares a property as reactive, and Vue will watch the changes and refresh the template accordingly.

```js
export default defineComponent({
name: 'Pony',
setup() {
const pony = reactive({
name: 'Rainbow Dash',
color: 'GREEN'
});
// update the name after 3 seconds
setTimeout(() => {
pony.name = 'Pinkie Pie';
}, 3000);
return { pony };
}
});
```

As you can see, no need for .value here when we want to update a property, and you can still use {{ pony.name }} in the template!
The cool thing is that works with all the nested properties of the object!

```js

```
