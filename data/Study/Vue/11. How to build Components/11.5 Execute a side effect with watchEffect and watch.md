
Sometimes, it’s necessary to know when the value of a property changes, but not necessarily to compute the value of another one.

For example, we may want to produce a side effect every time a property changes.

The typical example is a search UI, where you need to ask the server for new results every time the user enters a new query. Or if we go back to our Product component, maybe we want to keep track
of every change of the total value. That’s what the function watchEffect allows doing:

Product.vue
```js
const total = computed(() => state.price * state.quantity)
const totalHistory = ref<Array<string>>([])
watchEffect(
  // this is the effect called when one of its dependencies changes
  () => {
    totalHistory.value.push(`Total changed to ${total.value}`)
  }
)
```

As you can see, we can just define an effect to run, and Vue automatically tracks its dependencies, and re-runs the effect when a dependency changes.

We can access the new value and the old one if we need to, by using watch:

```js
const total = computed(() => state.price * state.quantity)
const totalHistory = ref<Array<string>>([])
watch(
  // this is the source of the watcher
  () => total.value,
  // this is the callback called when the source changes
  (newTotal, oldTotal) => {
    totalHistory.value.push(`Total changed from ${oldTotal} to ${newTotal}`)
  },
  // a watcher with a source is lazy by default
  // whereas a watcher with just an effect and no source is not
  // but we can make it run immediately with this option
  { immediate: true }
)
```


