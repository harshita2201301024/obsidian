Very often, you need to do some work when your component is initialized. Vue calls the setup
function right when it creates the component as we saw. It contains most of the setup process. So how can we call an API to populate a property after displaying the template for example? That’s where lifecycle functions are useful. You can use them inside the setup function, and they all work the same: they accept a function (that can be an async one) that will be executed by Vue at a specific time. We’ll see later that the setup function itself can be async in a specific case.

There are several of them that you can use, each corresponding to a particular instant of the
component’s life. The main ones are:
• onBeforeMount/onMounted, called before/after the component has been mounted (inserted in the DOM); (there’s probably a joke about "mount the pony", but let’s stay focus)
• onBeforeUpdate/onUpdated, called before/after the component has been updated; (something changed, and the DOM re-rendered)
• onBeforeUnmount/onUnmounted, called before/after the component has been destroyed; (removed from the DOM)
• onErrorCaptured called if there is an error in one of the descendent components.
Let’s see a few examples.

11.8.1 Initialize your component with onMounted()

A very frequent usage of onMounted is to call an asynchronous API to initialize one of the reactive property of the component. If fetchRace() is an asynchronous function (it is, as we are asking the backend via an HTTP call), then we can write:

```js
props: {
raceId: {
type: Number,
required: true
}
},
setup(props) {
const race = ref<RaceModel | null>(null);
// we fetch the details of the race based on its ID
onMounted(async () => {
race.value = await fetchRace(props.raceId);
});
return { race };
}
```


