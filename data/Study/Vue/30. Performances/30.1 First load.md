Be careful with premature optimization. Always measure before and after. Beware
off the benchmarks you find on the internets: it’s pretty easy to make them say
what the authors want.
Performances can mean a lot of things: speed, CPU usage (battery consumption), memory
pressure…
Everything is not important for everybody: you have different needs if you are programming for a
mobile website, an e-commerce platform, or a classic CRUD application.
Performances can also be split into different categories, that, once more, won’t all matter to you:
first load, reload, and runtime performances.
First load is when you open an application for the first time. Reload is when you come back to that
application. Runtime performances is what happens when the application is running. Some of the
following recommendations are very generic, and could be applied to any framework. We wrote
them down because we think it’s worth knowing. And because when you talk about performances,
the framework is sometimes the bottleneck, but really (really) often not.

30.1. First load
When you load a modern Web application in your browser, a few things happen. First, the
index.html is loaded and parsed by the browser. Then the JS scripts and other assets referenced are
fetched. When one of the assets is received, the browser parses it, and executes it if it is a JS file.
30.2. Asset sizes
So the first tip is very obvious: be careful with your asset sizes!
The assets loading phase depends on how many assets you want to load. A lot will be slow. Big ones
will be slow. Especially if the network is not that good, which happens more often than you think:
you might test your application on an optical fiber connection, but some of your actual users might
be in the middle of nowhere, using slow 3G. Here is what you can do.

30.3. Bundle your application
When you write your Vue application, you have imports all over the place, and your code is split
across hundreds of files. But you don’t want your users to load hundreds of files! So before shipping
your application, you want to make a "bundle": group all the JavaScript files into one file.
Rollup (for Vite) or Webpack (for the CLI) jobs are to take all your JavaScript files (and CSS, and
template HTML files) and build bundles.
They are not easy tools to master, but Vite and the Vue CLI do a pretty good job at hiding their
complexity. If you don’t use Vite or the CLI, you can build your application with Rollup or Webpack
directly, or you can pick another tool that may produce even better results. But be warned that this
requires quite a lot of expertise (and work) to not mess things up, just to save a few extra kilobytes.
I would recommend staying with Vite (ideally) or the CLI.
The team working on these tools are doing a very good job keeping up with the latest Vue,
TypeScript and bundler releases.

30.4. Tree-shaking
Rollup and Webpack (or other tools you use) start from the entry point of your application (the
main.ts file generated for you), then resolves all the imports tree, and outputs the bundle. This is
cool because the bundle will only contain the files from your codebase and your third party
libraries that have been imported. The rest is not embedded. So even if you have a dependency in
your package.json that you don’t use anymore (so you don’t import it anymore), it will not end up in
the bundle.
It’s even a bit smarter than that. If you have a file utils exporting two functions, let’s say start()
and stop(), and then only import start() into the rest of the application, but never stop(), then the
bundler only puts start() in the final bundle, and drops stop(). This process is called tree-shaking.
And every framework and library in the JavaScript ecosystem is fighting hard to be tree-shakable!
In theory, it means that your final bundle contains only what is really needed! But in practice,
bundlers are a bit conservative, and can’t figure out some stuff. For example, if you have a class
Pony with two methods eat and run, but you only use run, the code of the eat method will be in the
final bundle. So it’s not perfect, but it does a good job.

30.5. Minification and dead code elimination
When your bundle has been built, the code is usually minified and dead code will be eliminated.
That means all variables, method names, class names… are renamed to use a one or two characters
name through the entire codebase. This is a bit scary and sounds like it could break things, but
ESBuild or Terser have been doing a great job. They will also eliminate dead code that they can
find.

30.6. Other assets
While the above sections were about JS specifically, your application also contains other assets, like
styles, images, fonts… You should have the same concerns about them, and do your best to keep
them at a reasonable size. Applying all kinds of crazy techniques to optimize your JS bundle sizes,
but loading several MBs of images, wouldn’t have a big impact on your page loading time and your
bandwidth! As this is not really the scope of this ebook, I won’t dig into this topic, but let me point
out a great online resource by Addy Osmani about image optimization: Essential Image
Optimization.
30.7. Compression
All the modern browsers accept a compressed version of an asset when they ask the server for it.
That means you can serve a compressed version to your users, and the browser will unzip it before
parsing it. This is a must-do because it will save you tons of bandwidth and loading time!
Every server on the market gives the option of activating the compression of assets. Generally the
first user to request an asset will pay the cost of the compression on the fly, and then the following
ones will receive the compressed asset directly.
The most common compression algorithm used is GZIP, but some others like Brotli are also popular.

30.8. Lazy-loading
Sometimes, despite doing your best to keep your JS bundle small, you end up with a big file because
your app has grown to several dozens of components, using various third party libraries. And not
only will this big bundle increase the time needed to fetch the JavaScript, it will also increase the
time needed to parse it and execute it.
One common solution to this problem is to use lazy-loading. It means that instead of having a big
bundle of JavaScript, you split your application into several parts and tell the bundler to split it in
several bundles.
The good news is that Vue (and its router) makes this task relatively easy to achieve. You can read
our chapter about lazy-loading if you want to learn more.
Lazy-loading can vastly improve the loading time, as you can make the first bundle really small,
with only what’s needed to display the home page, and let Vue load the rest on demand when your
user navigates to another part.





